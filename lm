#!/usr/bin/env bash

# Pre-requisits
# -------------
#
# The following environment variables must be set:
#   LOGGER_BASE_DIR
#   DATA_DIR

print_error()
{
    echo -e $1 >/dev/stderr
}

check_return_value ()
{
    if [ $? -ne 0 ]
    then
	print_error "ERROR. lm.sh script cannot finished. Please see above for error details.\n"
	exit $?
    fi
}


check_directory ()
# Arguments: 1) path
{
    if [ -z "$1" ] # -z true if length of string is zero
    then
	print_error "\n* ERROR: $1 Path is an empty string!\n"
	exit 1
    else
	if [ ! -d "$1" ] # -d true if file exists and is a directory
	then
	    print_error "\n* ERROR: $1 IS NOT A DIRECTORY\n"
	    exit 1
	fi
    fi    
}


start_process ()
# Arguments: 1) directory, 2) file within directory, 3) process name
{
    echo -e "==================="
    echo -e "\nStarting $1/$2..."

    # Check if it's already running
    pgrep $3 > /dev/null
    if [ $? -eq 0 ]
    then
	echo -e "$3 is already running so not re-starting it."
	return
    fi

    # Start the process
    cd $1
    nohup $2 &

    # Pause for 1 second
    sleep 1

    # Check if it's running
    pgrep $3 > /dev/null
    if [ $? -eq 0 ]
    then
	echo "Successfully started $1/$2"
    else
	print_error "ERROR **** FAILED TO START $1/$2 **********"
	tail nohup.out >/dev/stderr
	echo ""
    fi
}

wait_for_process_to_die ()
# Arguments: 1) process name
# Returns: 0 if process dies, 1 if process doesn't die
{
    MAX_SECONDS_TO_WAIT=10
    for (( i=0; i<MAX_SECONDS_TO_WAIT; i++ ))
    do
	pgrep "$1" > /dev/null
	if [ $? -ne 0 ]
	then
	    return 0
	fi
	sleep 1 # sleep for 1 second
	echo "...waiting for $1 to die..."
    done
    return 1
}

kill_process ()
# Arguments: 1) process name
{
    echo -e "\n====================\n"
    pgrep "$1" > /dev/null
    if [ $? -eq 0 ]
    then
	echo "$1 is running so attempting to kill it:"
	echo "/bin/kill $(pgrep "$1")"
	/bin/kill $(pgrep "$1")

	wait_for_process_to_die "$1"
	if [ $? -eq 1 ]
	then
	    print_error "ERROR: Failed to kill $1. Will try again with '/bin/kill -s KILL'"
	    /bin/kill -s KILL $(pgrep "$1")

	    # check if we succeeded with -s KILL
	    pgrep "$1" > /dev/null
	    if [ $? -eq 1 ]
	    then
		echo "Successfully killed $1"
	    else
		echo "ERROR: Failed to kill $1 using -s KILL"
		echo "       Perhaps you don't have permission? Try using 'sudo lm stop'"
	    fi
	else
	    echo "Successfull killed $1"
	fi
    else
	echo "$1 is not running so no need to kill it."
    fi

}

echo ""

name[0]="rfm_ecomanager_logger"
name[1]="powerstats"
name[2]="babysitter"
name[3]="snd_card_power_meter"

length=${#name[@]} # length of array `name`

# create a `directory` array with the actual directories and sanity check
for (( i=0; i<$length; i++ ))
do
    directory[$i]="${LOGGER_BASE_DIR}/${name[$i]}"
    check_directory "${directory[$i]}"
done

RFM_ECOMANAGER_LOGGER_DIR="${directory[0]}"
POWERSTATS_DIR="${directory[1]}"
BABYSITTER_DIR="${directory[2]}"
SND_CARD_POWER_METER="${directory[3]}"

case "$1" in # switch on the first command

"update")
	echo "Updating code from github"
	for (( i=0; i<$length; i++ ))
	do
	    echo ""
	    echo "Updating ${name[$i]}"
	    cd ${directory[$i]} && git pull
	    check_return_value
	done
	;;

"flash")
	echo "Flashing Nanode with latest code from github"

	echo "Checking whether rfm_ecomanager_logger is running:"
	pgrep rfm_ecomanager_ > /dev/null
	if [ $? -eq 0 ]
	then
	    print_error "ERROR: rfm_ecomager_logger is running."
	    print_error "       Stop it using 'lm stop' and then try 'lm flash' again.\n"
	    exit 1
	else
	    echo "Good. rfm_ecomanager_logger is not running.  Continuing..."
	fi

	echo "First, updating code from github:"
	cd "$RFM_EDF_ECOMANAGER_DIR" && git pull
	check_return_value

	echo "Running flash.sh script:"
	./flash.sh
	check_return_value
	;;

"start")
	start_process "$RFM_ECOMANAGER_LOGGER_DIR" "rfm_ecomanager_logger/rfm_ecomanager_logger.py" "rfm_ecomanager_"
	sleep 1

	echo "Checking the rfm_ecomanager_logger.py really is running..."
	pgrep rfm_ecomanager_ > /dev/null
	if [ $? -eq 0 ]
	then
	    echo "$name is running"
	else
	    print_error "ERROR $name FAILED TO START SO WILL NOT START BABYSITTER!\n"
	    exit 1
	fi	

	start_process "$BABYSITTER_DIR" "./power_babysitter.py" "power_babysitte"
	;;

"stop")
	echo "Stop logging"
	kill_process "power_babysitte"
	kill_process "rfm_ecomanager_"
	;;

"check")
	echo "Checking whether rfm_ecomanager_logger and power_babysitter are running..."
	for name in "rfm_ecomanager_" "power_babysitte"
	do
        echo -e "\n==================="	
	    echo -e "Checking $name..."
	    ps -A | grep "$name"
	    pgrep "$name" > /dev/null
	    if [ $? -eq 0 ]
	    then
		echo "$name is running"
	    else
		echo "$name is not running"
	    fi
	done
	;;

"data")
	check_directory "$DATA_DIR"
	echo "Displaying data.  Press CTRL-C to stop..."
	dirs=($(ls $DATA_DIR))
	dirs_length=${#dirs[@]} # length of array `dirs`
	last_element_num=$((dirs_length - 1))
	last_dir="$DATA_DIR/${dirs[$last_element_num]}"
	echo "Using directory $last_dir"
	echo ""
	tail -f $last_dir/*.dat
	;;
	
"edit")
    echo "Editing radioIDs.dat..."
    echo "Checking if rfm_ecomanager_logger is running..."
    pgrep rfm_ecomanager_ > /dev/null
    if [ $? -eq 0 ]
    then
	print_error "ERROR: rfm_ecomanager_logger is running. Please run 'lm stop' before 'lm edit'."
	exit 1
    else
	echo "Good: rfm_ecomanager_logger isn't running... starting editing mode..."
	$RFM_ECOMANAGER_LOGGER_DIR/rfm_ecomanager_logger/rfm_ecomanager_logger.py --edit
    fi
    ;;
    
"log")
    echo "Displaying tail of rfm_ecomanager_logger/*.log:"
    tail $RFM_ECOMANAGER_LOGGER_DIR/*.log
    echo ""
    echo "Displaying tail of babysitter/*.log:"
    tail $BABYSITTER_DIR/*.log
    ;;

"stats")
    echo "Running stats"
    $POWERSTATS_DIR/powerstats/powerstats.py --numeric-subdirs
    ;;

*)
	echo -e "Usage: 'lm {edit|update|flash|start|stop|check|data|log}'\n"
	echo -e "Typical usage pattern:"
	echo -e "  1) Teach the logging system about your sensors using 'lm edit'"
	echo -e "  2) Start logging using 'lm start'"
	echo -e "  3) Check that the logging processes really are running with 'lm check'"
	echo -e "  4) Check the relevant log files with 'lm log'"
	echo -e "  5) Check that data are coming in using 'lm data'"
	echo -e "  6) Then, when you've finished logging, use 'lm stop'"
	echo -e "  7) Update the Nanode's flash with the latest code using 'lm flash'\n"
	exit 1
	;;

esac # end of case

